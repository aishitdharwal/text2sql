# Query Caching with DynamoDB

## Overview

DynamoDB-based query caching system that stores generated SQL queries to avoid redundant Claude API calls. Automatically invalidates cache when database schema changes.

---

## How It Works

```
1. User asks: "Show me total revenue"
2. Calculate schema_version from table/column structure
3. Generate cache_key = hash(query + database + schema_version)
4. Check DynamoDB:
   - CACHE HIT ‚Üí Return cached SQL (< 50ms)
   - CACHE MISS ‚Üí Call Claude API ‚Üí Store in cache ‚Üí Return SQL
```

---

## Architecture

### Cache Key Strategy
```python
cache_key = SHA256(
    natural_language_query.lower() +
    database_name +
    schema_version
)
```

### Schema Version
```python
# Automatically computed from database structure
schema_version = MD5(
    sorted_table_names +
    sorted_column_names +
    column_data_types
)
```

**Triggers cache invalidation:**
- ‚úÖ Table added/removed
- ‚úÖ Column added/removed/renamed
- ‚úÖ Column type changed

**Doesn't trigger invalidation:**
- ‚ùå Data changes
- ‚ùå Comment changes
- ‚ùå Index changes

### DynamoDB Table Schema

```
Table: text2sql_query_cache
Billing: PAY_PER_REQUEST (on-demand)
TTL: 30 days (configurable)

Primary Key:
- cache_key (String, HASH) - SHA256 hash

Attributes:
- natural_language_query (String)
- database_name (String)
- schema_version (String)
- generated_sql (String)
- hit_count (Number) - Increments on each cache hit
- created_at (Number) - Unix timestamp
- last_accessed_at (Number) - Updated on cache hit
- ttl (Number) - Auto-delete timestamp

Global Secondary Index: database-index
- Partition Key: database_name
- Sort Key: created_at
- Purpose: Query all cached queries for a database
```

---

## Setup

### Step 1: Add to .env

```bash
# Enable caching
ENABLE_CACHE=true
CACHE_TABLE_NAME=text2sql_query_cache
CACHE_TTL_DAYS=30

# AWS credentials (or use IAM role)
AWS_REGION=ap-south-1
AWS_ACCESS_KEY_ID=your-key-id
AWS_SECRET_ACCESS_KEY=your-secret-key
```

### Step 2: IAM Permissions

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:CreateTable",
        "dynamodb:DescribeTable",
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:UpdateItem",
        "dynamodb:Query",
        "dynamodb:UpdateTimeToLive"
      ],
      "Resource": [
        "arn:aws:dynamodb:ap-south-1:*:table/text2sql_query_cache",
        "arn:aws:dynamodb:ap-south-1:*:table/text2sql_query_cache/index/*"
      ]
    }
  ]
}
```

### Step 3: Restart Backend

```bash
cd backend
./run.sh
```

**The table will be created automatically on first use!**

---

## Usage

### Automatic Caching

Caching happens transparently:

```python
# First request (CACHE MISS)
POST /api/generate-query
{
  "natural_language_query": "Show total revenue",
  "session_id": "..."
}

Response: {
  "success": true,
  "sql_query": "SELECT SUM(amount) FROM sales",
  "cached": false  // ‚Üê Generated by Claude
}

# Second identical request (CACHE HIT)
Response: {
  "success": true,
  "sql_query": "SELECT SUM(amount) FROM sales",
  "cached": true  // ‚Üê Returned from cache
}
```

### Disable Caching

```bash
# In .env
ENABLE_CACHE=false
```

---

## Monitoring

### CloudWatch Logs

All cache operations are logged:

```sql
-- Cache hits
fields @timestamp, database_name, hit_count
| filter message like /Cache HIT/
| sort @timestamp desc

-- Cache misses
fields @timestamp, database_name
| filter message like /Cache MISS/
| sort @timestamp desc

-- Cache hit rate
fields @timestamp
| filter message like /Cache/
| stats count(*) by message
```

### Cache Statistics

View in DynamoDB console:
1. Go to DynamoDB ‚Üí Tables ‚Üí text2sql_query_cache
2. Click "Explore table items"
3. View:
   - Total cached queries
   - Hit counts per query
   - Most popular queries (highest hit_count)
   - Recent queries (sort by created_at)

---

## Performance

### Typical Response Times

| Scenario | Time | Cost |
|----------|------|------|
| Cache HIT | 20-50ms | $0.00025/request |
| Cache MISS (generate) | 2-5s | $0.015/request |
| **Savings** | **100x faster** | **60x cheaper** |

### Cost Analysis

**Without cache:**
- 1000 requests/day √ó $0.015 = $15/day = **$450/month**

**With cache (50% hit rate):**
- 500 misses √ó $0.015 = $7.50/day
- 500 hits √ó $0.00025 = $0.125/day
- DynamoDB = $0.50/day
- **Total: $8.125/day = $244/month**
- **Savings: $206/month (46%)**

**With cache (80% hit rate):**
- 200 misses √ó $0.015 = $3/day
- 800 hits √ó $0.00025 = $0.20/day
- DynamoDB = $0.50/day
- **Total: $3.70/day = $111/month**
- **Savings: $339/month (75%)**

---

## Cache Invalidation

### Automatic Invalidation

Cache automatically invalidates when schema changes:

```sql
-- Add new table
CREATE TABLE new_table (...);
-- ‚Üí Schema version changes ‚Üí Cache misses ‚Üí Regenerates

-- Add column
ALTER TABLE customers ADD COLUMN email VARCHAR(255);
-- ‚Üí Schema version changes ‚Üí Cache misses ‚Üí Regenerates

-- Rename column
ALTER TABLE customers RENAME COLUMN name TO full_name;
-- ‚Üí Schema version changes ‚Üí Cache misses ‚Üí Regenerates
```

### Manual Cache Clear

```bash
# Delete specific database's cache
aws dynamodb query \
  --table-name text2sql_query_cache \
  --index-name database-index \
  --key-condition-expression "database_name = :db" \
  --expression-attribute-values '{":db":{"S":"sales_db"}}' \
  | jq -r '.Items[].cache_key.S' \
  | xargs -I {} aws dynamodb delete-item \
      --table-name text2sql_query_cache \
      --key '{"cache_key":{"S":"{}"}}'

# Or delete entire table
aws dynamodb delete-table --table-name text2sql_query_cache
# Will be recreated automatically on next request
```

---

## Analytics Queries

### Most Popular Queries

```sql
-- DynamoDB Query
aws dynamodb scan \
  --table-name text2sql_query_cache \
  --projection-expression "natural_language_query, hit_count, database_name" \
  | jq '.Items | sort_by(.hit_count.N | tonumber) | reverse | .[:10]'
```

### Cache Hit Rate by Database

```sql
-- CloudWatch Logs Insights
fields database_name, cached
| filter message like /SQL query/
| stats count(*) by database_name, cached
```

### Queries with Zero Hits

```sql
-- Find queries that were cached but never used again
aws dynamodb scan \
  --table-name text2sql_query_cache \
  --filter-expression "hit_count = :zero" \
  --expression-attribute-values '{":zero":{"N":"0"}}'
```

---

## Troubleshooting

### Cache not working

**1. Check logs:**
```bash
# Should see "Query cache enabled"
./run.sh | grep cache
```

**2. Check IAM permissions:**
```bash
aws dynamodb describe-table --table-name text2sql_query_cache
```

**3. Check table exists:**
```bash
aws dynamodb list-tables | grep text2sql_query_cache
```

### Always getting cache misses

**Check if queries are normalized:**
- "Show revenue" vs "show revenue" ‚Üí Same (lowercase)
- "Show revenue" vs "Show  revenue" ‚Üí Same (whitespace stripped)
- "Show revenue" vs "Display revenue" ‚Üí Different

### High costs

**Reduce TTL:**
```bash
# In .env
CACHE_TTL_DAYS=7  # Instead of 30
```

**Check for cache fragmentation:**
```bash
# Count total cached queries
aws dynamodb describe-table --table-name text2sql_query_cache \
  | jq '.Table.ItemCount'

# If > 10,000, consider cleanup
```

---

## Best Practices

‚úÖ **DO:**
- Use IAM roles instead of access keys
- Monitor cache hit rates
- Set appropriate TTL (7-30 days)
- Review popular queries for optimization

‚ùå **DON'T:**
- Store sensitive data in queries
- Set TTL too high (increases costs)
- Manually modify DynamoDB items
- Disable caching in production

---

## Advanced: Cache Warming

Pre-populate cache with common queries:

```python
# cache_warmer.py
common_queries = [
    "Show total revenue for last month",
    "List top 10 customers by revenue",
    "Show orders created today"
]

for query in common_queries:
    # Make request to warm cache
    requests.post('/api/generate-query', json={
        'natural_language_query': query,
        'session_id': session_id
    })
```

---

## Summary

‚úÖ **Automatic** - No code changes needed
‚úÖ **Fast** - 100x faster than API calls  
‚úÖ **Cost-effective** - 60-75% cost reduction
‚úÖ **Smart** - Auto-invalidates on schema changes
‚úÖ **Scalable** - Handles millions of queries
‚úÖ **Observable** - Full CloudWatch integration

**Cache is now production-ready! üéâ**
